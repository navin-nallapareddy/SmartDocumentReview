<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PDF Viewer (virtualized + fast highlights)</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf_viewer.min.css" />
  <style>
    html, body { margin: 0; height: 100%; }
    #viewerContainer {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: auto;
      background: #f5f5f5;
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }
    #viewer {
      position: relative;
      width: auto;
      min-width: 640px;
      padding: 16px 0;
    }

    /* Virtualized placeholders; real canvases exist only for active window */
    .pageSlot {
      margin: 16px auto;
      line-height: 0; /* remove inline-gap */
      background: transparent;
      contain: content; /* isolate layout/paint */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .pageLayer {
      position: relative;
      box-shadow: 0 1px 4px rgba(0,0,0,.2);
      background: white;
      line-height: 0;
      contain: layout paint size style;
    }

    canvas { display: block; }
    .renderCanvas { background: white; z-index: 0; }
    .hlCanvas {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: transparent;
      z-index: 1;
    }

    .pageMeta {
      font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: #666; text-align: center; padding: 6px 0 0;
    }
  </style>
</head>
<body>
  <div id="viewerContainer">
    <div id="viewer"></div>
  </div>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.min.js"></script>
  <script>
    (async function () {
      const params   = new URLSearchParams(location.search);
      const file     = params.get('file')    || '';
      const overlay  = params.get('overlay') || '';
      const startAt  = Math.max(1, parseInt(params.get('page') || '1', 10));

      if (!file) {
        console.error('Missing ?file=... parameter');
        return;
      }

      // PDF.js worker
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.worker.min.js';

      const viewer          = document.getElementById('viewer');
      const viewerContainer = document.getElementById('viewerContainer');

      // ---- Tuning knobs ----
      const CSS_SCALE = 1.25;                     // visual zoom (CSS pixels)
      const DPR_CAP   = 1.5;                      // cap DPR to keep canvases small
      const getDPR    = () => Math.min(window.devicePixelRatio || 1, DPR_CAP);
      let   CURRENT_DPR = getDPR();
      const ACTIVE_RADIUS = 3;                    // render Â±N pages around viewport
      const hw = navigator.hardwareConcurrency || 4;
      const CONCURRENCY = Math.min(6, Math.max(2, Math.floor(hw / 2)));

      // ---- Load highlights once ----
      let highlightsByPage = {};
      if (overlay) {
        try {
          const res = await fetch(overlay, { cache: 'no-store' });
          highlightsByPage = await res.json();
        } catch (e) {
          console.warn('Could not load overlay JSON:', e);
        }
      }

      // ---- Open PDF with streaming + larger range chunks ----
      const loadingTask = pdfjsLib.getDocument({
        url: file,
        rangeChunkSize: 1 << 20,   // 1 MiB ranged fetches
        disableAutoFetch: true,    // strict windowing; no runaway prefetch
        disableStream: false,      // allow streaming
        withCredentials: false
      });
      const pdf = await loadingTask.promise;
      const total = pdf.numPages;

      // ---- Virtualized DOM: lightweight slots only ----
      const slots = [];
      let estimatedCss = { width: 800, height: 1100 }; // updated after first page
      for (let p = 1; p <= total; p++) {
        const slot = document.createElement('div');
        slot.className = 'pageSlot';
        slot.dataset.pageNumber = String(p);
        slot.style.width  = estimatedCss.width + 'px';
        slot.style.height = (estimatedCss.height + 22) + 'px'; // +meta

        // meta below content
        const meta = document.createElement('div');
        meta.className = 'pageMeta';
        meta.textContent = `Page ${p} / ${total}`;

        // container for wrapper + meta
        const container = document.createElement('div');
        container.style.display = 'inline-block';
        container.appendChild(meta);

        slot.appendChild(container);
        viewer.appendChild(slot);
        slots.push({ slot, container, wrapper: null });
      }

      // ---- IntersectionObserver to track visibility without O(N) scans ----
      const visibleRatios = new Map(); // page -> intersectionRatio
      const io = new IntersectionObserver(entries => {
        for (const e of entries) {
          const p = Number(e.target.dataset.pageNumber);
          visibleRatios.set(p, e.isIntersecting ? e.intersectionRatio : 0);
        }
        scheduleWindowUpdate();
      }, {
        root: viewerContainer,
        rootMargin: '200% 0px',
        threshold: [0, 0.01, 0.25, 0.5, 0.75, 1]
      });
      for (const { slot } of slots) io.observe(slot);

      function nearestVisiblePage() {
        let best = 1, bestRatio = -1;
        for (const [p, r] of visibleRatios) {
          if (r > bestRatio) { bestRatio = r; best = p; }
        }
        return best;
      }

      // ---- Render queue + bookkeeping ----
      const renderTasks = new Map(); // pageNo -> { task, page }
      const rendered    = new Set(); // pages fully drawn
      const pending     = new Set(); // unique page numbers
      let inFlight = 0;
      let centerPage = 1;
      let firstViewportMeasured = false;

      function ensureWrapper(p, cssViewport, devViewport) {
        const entry = slots[p - 1];
        if (entry.wrapper) return entry.wrapper;

        const wrapper = document.createElement('div');
        wrapper.className = 'pageLayer';
        wrapper.dataset.pageNumber = String(p);

        const renderCanvas = document.createElement('canvas');
        renderCanvas.className = 'renderCanvas';

        const hlCanvas = document.createElement('canvas');
        hlCanvas.className = 'hlCanvas';

        wrapper.appendChild(renderCanvas);
        wrapper.appendChild(hlCanvas);

        // Insert wrapper above meta inside the slot's container
        entry.container.insertBefore(wrapper, entry.container.firstChild);
        entry.wrapper = wrapper;

        return wrapper;
      }

      function destroyWrapper(p) {
        const entry = slots[p - 1];
        if (!entry.wrapper) return;
        entry.container.removeChild(entry.wrapper);
        entry.wrapper = null;
      }

      function queueRender(p) {
        if (pending.has(p) || renderTasks.has(p) || rendered.has(p)) return;
        pending.add(p);
        pump();
      }

      function pickNextPage() {
        let best = null, bestScore = Infinity;
        for (const p of pending) {
          const score = Math.abs(p - centerPage);
          if (score < bestScore) { bestScore = score; best = p; }
        }
        if (best != null) pending.delete(best);
        return best;
      }

      async function pump() {
        while (inFlight < CONCURRENCY) {
          const p = pickNextPage();
          if (!p) return;
          inFlight++;

          try {
            const page = await pdf.getPage(p);
            const cssViewport = page.getViewport({ scale: CSS_SCALE });
            const devViewport = page.getViewport({ scale: CSS_SCALE * CURRENT_DPR });

            // Create wrapper and size canvases
            const wrapper = ensureWrapper(p, cssViewport, devViewport);
            const renderCanvas = wrapper.querySelector('.renderCanvas');
            const hlCanvas = wrapper.querySelector('.hlCanvas');

            renderCanvas.width  = Math.floor(devViewport.width);
            renderCanvas.height = Math.floor(devViewport.height);
            renderCanvas.style.width  = Math.floor(cssViewport.width) + 'px';
            renderCanvas.style.height = Math.floor(cssViewport.height) + 'px';

            hlCanvas.width  = renderCanvas.width;
            hlCanvas.height = renderCanvas.height;
            hlCanvas.style.width  = renderCanvas.style.width;
            hlCanvas.style.height = renderCanvas.style.height;

            wrapper.style.width  = renderCanvas.style.width;
            wrapper.style.height = renderCanvas.style.height;

            // Update placeholder dimensions once we know the real size
            if (!firstViewportMeasured) {
              firstViewportMeasured = true;
              estimatedCss = { width: Math.floor(cssViewport.width), height: Math.floor(cssViewport.height) };
              for (let i = 1; i <= total; i++) {
                if (!slots[i - 1].wrapper) {
                  slots[i - 1].slot.style.width  = estimatedCss.width + 'px';
                  slots[i - 1].slot.style.height = (estimatedCss.height + 22) + 'px';
                }
              }
            }

            const ctx = renderCanvas.getContext('2d', { alpha: false });
            const task = page.render({ canvasContext: ctx, viewport: devViewport });
            renderTasks.set(p, { task, page });

            await task.promise; // throws if canceled
            renderTasks.delete(p);

            if (Math.abs(p - centerPage) <= ACTIVE_RADIUS) {
              const rects = (highlightsByPage[String(p)] || highlightsByPage[p] || []);
              drawHighlights(hlCanvas, rects, cssViewport);
              rendered.add(p);
            } else {
              page.cleanup();
              destroyWrapper(p);
            }
          } catch (err) {
            if (!(err && (err.name === 'RenderingCancelled' || String(err).includes('Rendering cancelled')))) {
              console.warn('Render error on page', p, err);
            }
          } finally {
            inFlight--;
          }
        }
      }

      function updateActiveWindow() {
        centerPage = nearestVisiblePage();
        const minP = Math.max(1, centerPage - ACTIVE_RADIUS);
        const maxP = Math.min(total, centerPage + ACTIVE_RADIUS);

        const keep = new Set();
        for (let p = minP; p <= maxP; p++) {
          keep.add(p);
          if (!rendered.has(p) && !renderTasks.has(p)) queueRender(p);
        }

        // Cancel far-off render tasks and free memory
        for (const [p, obj] of Array.from(renderTasks.entries())) {
          if (!keep.has(p)) {
            try { obj.task.cancel(); } catch {}
            renderTasks.delete(p);
            obj.page?.cleanup();
          }
        }

        for (let p = 1; p <= total; p++) {
          if (!keep.has(p) && rendered.has(p)) {
            destroyWrapper(p);
            rendered.delete(p);
          }
        }

        // Keep the pump going in case new items were queued
        pump();
      }

      let scrollRAF = 0;
      function scheduleWindowUpdate() {
        if (scrollRAF) cancelAnimationFrame(scrollRAF);
        scrollRAF = requestAnimationFrame(() => {
          updateActiveWindow();
          scrollRAF = 0;
        });
      }

      viewerContainer.addEventListener('scroll', scheduleWindowUpdate, { passive: true });

      // ---- Highlight drawing (batched by color; rotation-safe) ----
      function drawHighlights(hlCanvas, rects, cssViewport) {
        const ctx = hlCanvas.getContext('2d', { alpha: true });
        ctx.clearRect(0, 0, hlCanvas.width, hlCanvas.height);
        ctx.globalAlpha = 0.3;
        // ctx.globalCompositeOperation = 'multiply'; // enable if specific blending is needed

        const dpr = CURRENT_DPR;
        requestAnimationFrame(() => {
          // group by color
          const groups = new Map();
          for (const r of rects) {
            const color = r.color || 'yellow';
            if (!groups.has(color)) groups.set(color, []);
            groups.get(color).push(r);
          }
          for (const [color, arr] of groups) {
            ctx.fillStyle = color;
            for (const r of arr) {
              const w = r.w ?? r.width, h = r.h ?? r.height;
              const [vx1, vy1] = cssViewport.convertToViewportPoint(r.x,     r.y);
              const [vx2, vy2] = cssViewport.convertToViewportPoint(r.x + w, r.y + h);
              const leftDev   = Math.round(Math.min(vx1, vx2) * dpr);
              const topDev    = Math.round(Math.min(vy1, vy2) * dpr);
              const widthDev  = Math.max(1, Math.round(Math.abs(vx2 - vx1) * dpr));
              const heightDev = Math.max(1, Math.round(Math.abs(vy2 - vy1) * dpr));
              ctx.fillRect(leftDev, topDev, widthDev, heightDev);
            }
          }
        });
      }

      // ---- Bootstrap: jump to requested page and compute initial window ----
      const startIndex = Math.min(total, Math.max(1, startAt)) - 1;
      slots[startIndex].slot.scrollIntoView({ block: 'start' });
      updateActiveWindow();

      // ---- Handle resize / DPR changes: re-render only the active window ----
      window.addEventListener('resize', () => {
        const newDpr = getDPR();
        if (Math.abs(newDpr - CURRENT_DPR) > 0.001) {
          CURRENT_DPR = newDpr;
        }
        const center = nearestVisiblePage();
        const minP = Math.max(1, center - ACTIVE_RADIUS);
        const maxP = Math.min(total, center + ACTIVE_RADIUS);
        for (let p = minP; p <= maxP; p++) {
          if (rendered.has(p)) {
            destroyWrapper(p);
            rendered.delete(p);
            queueRender(p);
          }
        }
      });

      // ---- Clean up on unload ----
      window.addEventListener('beforeunload', () => {
        try { loadingTask?.destroy(); } catch {}
      });
    })();
  </script>
</body>
</html>
