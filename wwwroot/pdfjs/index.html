<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PDF Viewer</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf_viewer.min.css" />
  <style>
    html, body { margin: 0; height: 100%; }
    #viewerContainer {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: auto;
      background: #f5f5f5;
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }
    .pageLayer {
      position: relative;
      margin: 16px;
      box-shadow: 0 1px 4px rgba(0,0,0,.2);
      background: white;
      line-height: 0;
    }
    canvas { display: block; background: white; }
    /* highlight canvas sits on top, mouse goes through */
    #hl-canvas {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="viewerContainer">
    <div id="pageWrapper" class="pageLayer">
      <canvas id="the-canvas"></canvas>
      <canvas id="hl-canvas"></canvas>
    </div>
  </div>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.min.js"></script>
  <script>
    (async function () {
      const urlParams = new URLSearchParams(location.search);
      const file    = urlParams.get('file')    || '';
      const pageNum = parseInt(urlParams.get('page') || '1', 10);
      const overlay = urlParams.get('overlay') || ''; // e.g. /uploads/latest-highlights.json

      if (!file) {
        console.error('Missing ?file=... parameter');
        return;
      }

      pdfjsLib.GlobalWorkerOptions.workerSrc =
        'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.worker.min.js';

      const pageWrapper = document.getElementById('pageWrapper');
      const renderCanvas = document.getElementById('the-canvas');
      const hlCanvas = document.getElementById('hl-canvas');
      const renderCtx = renderCanvas.getContext('2d');

      const CSS_SCALE = 1.5;                  // how big the page looks in CSS px
      const DPR = window.devicePixelRatio || 1; // for sharp rendering

      // Load PDF + page
      const pdf = await pdfjsLib.getDocument(file).promise;
      const page = await pdf.getPage(pageNum);

      // Viewport for CSS geometry (no DPR)
      const cssViewport = page.getViewport({ scale: CSS_SCALE });

      // Size main render canvas (device pixels)
      renderCanvas.width  = Math.floor(cssViewport.width  * DPR);
      renderCanvas.height = Math.floor(cssViewport.height * DPR);
      renderCanvas.style.width  = Math.floor(cssViewport.width)  + 'px';
      renderCanvas.style.height = Math.floor(cssViewport.height) + 'px';

      // Size highlight canvas to match (both CSS size and backing store)
      hlCanvas.width  = renderCanvas.width;
      hlCanvas.height = renderCanvas.height;
      hlCanvas.style.width  = renderCanvas.style.width;
      hlCanvas.style.height = renderCanvas.style.height;

      // Fit wrapper to page CSS size
      pageWrapper.style.width  = renderCanvas.style.width;
      pageWrapper.style.height = renderCanvas.style.height;

      // Render PDF page at DPR scale
      const deviceViewport = page.getViewport({ scale: CSS_SCALE * DPR });
      await page.render({ canvasContext: renderCtx, viewport: deviceViewport }).promise;

      // Fetch highlights
      let rects = [];
      if (overlay) {
        try {
          const res = await fetch(overlay, { cache: 'no-store' });
          const byPage = await res.json();
          rects = byPage[String(pageNum)] || byPage[pageNum] || [];
        } catch (e) {
          console.warn('Could not load overlay JSON:', e);
        }
      }

      // Draw all highlights on one canvas (super fast)
      function drawHighlights(rects) {
        const ctx = hlCanvas.getContext('2d', { alpha: true, willReadFrequently: false });
        ctx.clearRect(0, 0, hlCanvas.width, hlCanvas.height);

        // Style (tweak to taste)
        ctx.globalAlpha = 0.3;
        ctx.globalCompositeOperation = 'multiply';

        // PDF coords are in points with origin bottom-left.
        // Map to device pixels (DPR applied) with the same scale used for rendering.
        const s = CSS_SCALE * DPR;
        const pageHeightCss = cssViewport.height; // CSS px
        const pageHeightDev = pageHeightCss * DPR; // device px for Y inversion

        // Optional: if your JSON carries colors, group by color to reduce state changes
        // For simplicity, do a single pass:
        requestAnimationFrame(() => {
          for (let i = 0; i < rects.length; i++) {
            const r = rects[i];
            // Support both {w,h} and {width,height} shapes
            const w = r.w ?? r.width;
            const h = r.h ?? r.height;

            const x = (r.x * s) | 0;
            const yTop = pageHeightDev - ((r.y + h) * s);
            const wpx = (w * s) | 0;
            const hpx = (h * s) | 0;

            if (r.color) {
              ctx.fillStyle = r.color; // e.g., "rgba(255,255,0,1)" or "yellow"
            } else {
              ctx.fillStyle = 'yellow';
            }
            ctx.fillRect(x, yTop, wpx, hpx);
          }
        });
      }

      drawHighlights(rects);

      // (Optional) If you add zooming later, re-run render + drawHighlights with the new scale.
    })();
  </script>
</body>
</html>
