<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PDF Viewer (virtualized + fast highlights)</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf_viewer.min.css" />
  <style>
    html, body { margin: 0; height: 100%; }
    #viewerContainer {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: auto;
      background: #f5f5f5;
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }
    #viewer {
      position: relative;
      width: auto;
      min-width: 640px;
      padding: 16px 0;
    }

    /* Virtualized placeholders; real canvases exist only for active window */
    .pageSlot {
      margin: 16px auto;
      line-height: 0; /* remove inline-gap */
      background: transparent;
      contain: content; /* isolate layout/paint */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .pageLayer {
      position: relative;
      box-shadow: 0 1px 4px rgba(0,0,0,.2);
      background: white;
      line-height: 0;
      contain: layout paint size style;
    }

    canvas { display: block; }
    .renderCanvas { background: white; z-index: 0; }
    .hlCanvas {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: transparent;
      z-index: 1;
    }

    .pageMeta {
      font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: #666; text-align: center; padding: 6px 0 0;
    }
  </style>
</head>
<body>
  <div id="viewerContainer">
    <div id="viewer"></div>
  </div>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.min.js"></script>
  <script>
    (async function () {
      const params   = new URLSearchParams(location.search);
      const file     = params.get('file')    || '';
      const overlay  = params.get('overlay') || '';
      const startAt  = Math.max(1, parseInt(params.get('page') || '1', 10));

      if (!file) {
        console.error('Missing ?file=... parameter');
        return;
      }

      // --- PERF LOGGING ---
      const t0 = performance.now();
      const mark = (msg) => console.log(`[perf] ${msg}: ${(performance.now()-t0).toFixed(1)}ms`);

      // Safari/older browsers: requestIdleCallback polyfill
      const _rIC = window.requestIdleCallback || function (cb, opts) {
        return setTimeout(() => cb({ timeRemaining: () => 0, didTimeout: true }), (opts && opts.timeout) || 0);
      };
      const _cIC = window.cancelIdleCallback || function (id) { clearTimeout(id); };
      const idleTick = (timeout = 50) => new Promise((resolve) => _rIC(resolve, { timeout }));

      // Verify worker actually loads (fallback = very slow)
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.worker.min.js';
      mark('worker configured');

      const viewer          = document.getElementById('viewer');
      const viewerContainer = document.getElementById('viewerContainer');

      // ---- Tuning knobs ----
      const CSS_SCALE = 1.25;
      const DPR_CAP   = 1.5;
      const getDPR    = () => Math.min(window.devicePixelRatio || 1, DPR_CAP);
      let   CURRENT_DPR = getDPR();
      const ACTIVE_RADIUS = 2; // tighter window for faster startup
      const hw = navigator.hardwareConcurrency || 4;
      const CONCURRENCY = Math.min(8, Math.max(2, Math.floor(hw - 1))); // use CPU better

      // ---- Load highlights once ----
      let highlightsByPage = {};
      if (overlay) {
        try {
          const res = await fetch(overlay, { cache: 'no-store' });
          highlightsByPage = await res.json();
        } catch (e) { console.warn('Could not load overlay JSON:', e); }
      }

      // ---- Open PDF with streaming + larger range chunks ----
      const PDFJS_VER = '2.14.305';
      const CDN = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${PDFJS_VER}/`;

      // Robust worker setup: if CDN worker is blocked by CSP/CORS, build a same-origin Blob worker.
      async function ensureWorker() {
        try {
          // quick HEAD to see if worker is reachable
          const res = await fetch(CDN + 'pdf.worker.min.js', { method: 'HEAD' });
          if (!res.ok) throw new Error('worker not reachable');
          pdfjsLib.GlobalWorkerOptions.workerSrc = CDN + 'pdf.worker.min.js';
        } catch (e) {
          console.warn('[worker] cdn worker blocked, falling back to blob worker', e);
          try {
            const js = await (await fetch(CDN + 'pdf.worker.min.js')).text();
            const blob = new Blob([js], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);
            pdfjsLib.GlobalWorkerOptions.workerSrc = url;
          } catch (e2) {
            console.warn('[worker] blob worker failed, disabling worker (slow)', e2);
            pdfjsLib.GlobalWorkerOptions.workerSrc = '';
            pdfjsLib.disableWorker = true;
          }
        }
      }
      await ensureWorker();

      const loadingTask = pdfjsLib.getDocument({
        url: file,
        rangeChunkSize: 1 << 20,   // 1 MiB
        disableAutoFetch: true,
        disableStream: false,
        withCredentials: false,
        // Many deployments block eval via CSP; enable safe font parsing path
        isEvalSupported: false,
        cMapUrl: CDN + 'cmaps/',
        cMapPacked: true,
        standardFontDataUrl: CDN + 'standard_fonts/'
      });

      // 1) Render ONLY the requested page ASAP (no DOM for others yet).
      const pdf = await loadingTask.promise;
      const total = pdf.numPages;
      mark('pdf loaded');

      const startP = Math.min(total, Math.max(1, startAt));
      const page   = await pdf.getPage(startP);
      const cssViewport = page.getViewport({ scale: CSS_SCALE });
      const devViewport = page.getViewport({ scale: CSS_SCALE * CURRENT_DPR });

      // Minimal DOM just for first page to get first paint fast
      const slot = document.createElement('div');
      slot.className = 'pageSlot';
      slot.dataset.pageNumber = String(startP);

      const container = document.createElement('div');
      container.style.display = 'inline-block';

      const wrapper = document.createElement('div');
      wrapper.className = 'pageLayer';
      wrapper.dataset.pageNumber = String(startP);

      const renderCanvas = document.createElement('canvas');
      renderCanvas.className = 'renderCanvas';
      renderCanvas.width  = Math.floor(devViewport.width);
      renderCanvas.height = Math.floor(devViewport.height);
      renderCanvas.style.width  = Math.floor(cssViewport.width) + 'px';
      renderCanvas.style.height = Math.floor(cssViewport.height) + 'px';

      const hlCanvas = document.createElement('canvas');
      hlCanvas.className = 'hlCanvas';
      hlCanvas.width  = renderCanvas.width;
      hlCanvas.height = renderCanvas.height;
      hlCanvas.style.width  = renderCanvas.style.width;
      hlCanvas.style.height = renderCanvas.style.height;

      wrapper.appendChild(renderCanvas);
      wrapper.appendChild(hlCanvas);

      const meta = document.createElement('div');
      meta.className = 'pageMeta';
      meta.textContent = `Page ${startP} / ${total}`;

      container.appendChild(wrapper);
      container.appendChild(meta);
      slot.appendChild(container);
      viewer.appendChild(slot);

      // Immediate render of first page
      const ctx = renderCanvas.getContext('2d', { alpha: false });
      const firstTask = page.render({ canvasContext: ctx, viewport: devViewport });
      await firstTask.promise;
      mark('first page rendered');

      // Draw highlights for first page
      const rects0 = (highlightsByPage[String(startP)] || highlightsByPage[startP] || []);
      drawHighlights(hlCanvas, rects0, cssViewport);

      // 2) Now that we have true size, build virtualized structure for ALL pages in idle time
      const slots = [];
      let estimatedCss = { width: Math.floor(cssViewport.width), height: Math.floor(cssViewport.height) };

      // Insert placeholders before and after the already-rendered page without long tasks
      async function buildSlotsInBatches() {
        const BATCH = 200;
        // before
        for (let i = startP - 1; i >= 1; i -= BATCH) {
          await idleTick(50);
          for (let p = Math.max(1, i - BATCH + 1); p <= i; p++) addSlot(p);
        }
        // after
        for (let i = startP + 1; i <= total; i += BATCH) {
          await idleTick(50);
          for (let p = i; p <= Math.min(total, i + BATCH - 1); p++) addSlot(p);
        }
      }

      function addSlot(p) {
        if (p === startP) { slots[p - 1] = { slot, container, wrapper }; return; }
        const s = document.createElement('div');
        s.className = 'pageSlot';
        s.dataset.pageNumber = String(p);
        s.style.width  = estimatedCss.width + 'px';
        s.style.height = (estimatedCss.height + 22) + 'px';

        const c = document.createElement('div');
        c.style.display = 'inline-block';
        const m = document.createElement('div');
        m.className = 'pageMeta';
        m.textContent = `Page ${p} / ${total}`;
        c.appendChild(m);
        s.appendChild(c);

        if (p < startP) viewer.insertBefore(s, viewer.firstChild);
        else viewer.appendChild(s);
        slots[p - 1] = { slot: s, container: c, wrapper: null };
      }

      try { await buildSlotsInBatches(); } catch (e) { console.warn('slot build interrupted', e); }
      viewerContainer.scrollTop = slots[startP - 1].slot.offsetTop;
      mark('all placeholders built');

      // ---- IntersectionObserver (observe only after slots exist) ----
      const visibleRatios = new Map();
      const io = new IntersectionObserver(entries => {
        for (const e of entries) {
          const p = Number(e.target.dataset.pageNumber);
          visibleRatios.set(p, e.isIntersecting ? e.intersectionRatio : 0);
        }
        scheduleWindowUpdate();
      }, { root: viewerContainer, rootMargin: '200% 0px', threshold: [0, 0.01, 0.25, 0.5, 0.75, 1] });
      for (const it of slots) if (it) io.observe(it.slot);

      function nearestVisiblePage() {
        let best = startP, bestRatio = -1;
        for (const [p, r] of visibleRatios) { if (r > bestRatio) { bestRatio = r; best = p; } }
        return best;
      }

      const renderTasks = new Map();
      const rendered    = new Set();
      const pending     = new Set();
      let inFlight = 0;
      let centerPage = startP;

      function ensureWrapper(p, cssViewport, devViewport) {
        const entry = slots[p - 1];
        if (entry.wrapper) return entry.wrapper;
        const w = document.createElement('div');
        w.className = 'pageLayer';
        w.dataset.pageNumber = String(p);
        const rc = document.createElement('canvas'); rc.className = 'renderCanvas';
        const hc = document.createElement('canvas'); hc.className = 'hlCanvas';
        w.appendChild(rc); w.appendChild(hc);
        entry.container.insertBefore(w, entry.container.firstChild);
        entry.wrapper = w;
        return w;
      }
      function destroyWrapper(p) {
        const e = slots[p - 1]; if (!e || !e.wrapper) return; e.container.removeChild(e.wrapper); e.wrapper = null;
      }
      function queueRender(p) { if (pending.has(p) || renderTasks.has(p) || rendered.has(p)) return; pending.add(p); pump(); }
      function pickNextPage() { let best=null,b=1e9; for (const p of pending){ const s=Math.abs(p-centerPage); if(s<b){b=s;best=p;}} if(best!=null) pending.delete(best); return best; }

      async function pump() {
        while (inFlight < CONCURRENCY) {
          const p = pickNextPage(); if (!p) return; inFlight++;
          try {
            const page = await pdf.getPage(p);
            const cssV = page.getViewport({ scale: CSS_SCALE });
            const devV = page.getViewport({ scale: CSS_SCALE * CURRENT_DPR });
            const wrapper = ensureWrapper(p, cssV, devV);
            const rc = wrapper.querySelector('.renderCanvas');
            const hc = wrapper.querySelector('.hlCanvas');
            rc.width = Math.floor(devV.width); rc.height = Math.floor(devV.height);
            rc.style.width = Math.floor(cssV.width)+'px'; rc.style.height = Math.floor(cssV.height)+'px';
            hc.width = rc.width; hc.height = rc.height; hc.style.width = rc.style.width; hc.style.height = rc.style.height;
            wrapper.style.width = rc.style.width; wrapper.style.height = rc.style.height;
            const ctx = rc.getContext('2d', { alpha:false });
            const task = page.render({ canvasContext: ctx, viewport: devV });
            renderTasks.set(p, { task, page });
            await task.promise; renderTasks.delete(p);
            if (Math.abs(p - centerPage) <= ACTIVE_RADIUS) { const rects=(highlightsByPage[String(p)]||highlightsByPage[p]||[]); drawHighlights(hc, rects, cssV); rendered.add(p); }
            else { page.cleanup(); destroyWrapper(p); }
          } catch (err) {
            if (!(err && (err.name === 'RenderingCancelled' || String(err).includes('Rendering cancelled')))) console.warn('Render error on page', p, err);
          } finally { inFlight--; }
        }
      }

      function updateActiveWindow() {
        centerPage = nearestVisiblePage();
        const minP = Math.max(1, centerPage - ACTIVE_RADIUS);
        const maxP = Math.min(total, centerPage + ACTIVE_RADIUS);
        const keep = new Set();
        for (let p=minP; p<=maxP; p++){ keep.add(p); if(!rendered.has(p) && !renderTasks.has(p)) queueRender(p); }
        for (const [p, obj] of Array.from(renderTasks.entries())) { if (!keep.has(p)) { try{obj.task.cancel();}catch{} renderTasks.delete(p); obj.page?.cleanup(); } }
        for (let p=1;p<=total;p++){ if(!keep.has(p) && rendered.has(p)){ destroyWrapper(p); rendered.delete(p);} }
        pump();
      }

      let scrollRAF = 0;
      function scheduleWindowUpdate(){ if(scrollRAF) cancelAnimationFrame(scrollRAF); scrollRAF = requestAnimationFrame(()=>{ updateActiveWindow(); scrollRAF=0; }); }
      viewerContainer.addEventListener('scroll', scheduleWindowUpdate, { passive:true });

      function drawHighlights(hlCanvas, rects, cssViewport) {
        const ctx = hlCanvas.getContext('2d', { alpha: true });
        ctx.clearRect(0, 0, hlCanvas.width, hlCanvas.height);
        ctx.globalAlpha = 0.3;
        const dpr = CURRENT_DPR;
        requestAnimationFrame(() => {
          const groups = new Map();
          for (const r of rects) { const color=r.color||'yellow'; if(!groups.has(color)) groups.set(color, []); groups.get(color).push(r); }
          for (const [color, arr] of groups) {
            ctx.fillStyle = color;
            for (const r of arr) {
              const w=r.w??r.width, h=r.h??r.height;
              const [vx1, vy1] = cssViewport.convertToViewportPoint(r.x, r.y);
              const [vx2, vy2] = cssViewport.convertToViewportPoint(r.x+w, r.y+h);
              const leftDev=Math.round(Math.min(vx1,vx2)*dpr);
              const topDev=Math.round(Math.min(vy1,vy2)*dpr);
              const widthDev=Math.max(1, Math.round(Math.abs(vx2-vx1)*dpr));
              const heightDev=Math.max(1, Math.round(Math.abs(vy2-vy1)*dpr));
              ctx.fillRect(leftDev, topDev, widthDev, heightDev);
            }
          }
        });
      }

      // Kick initial window around the already-rendered page
      updateActiveWindow();

      // Handle resize / DPR changes
      window.addEventListener('resize', () => {
        const newDpr = getDPR(); if (Math.abs(newDpr - CURRENT_DPR) > 0.001) CURRENT_DPR = newDpr;
        const center = nearestVisiblePage();
        const minP = Math.max(1, center - ACTIVE_RADIUS);
        const maxP = Math.min(total, center + ACTIVE_RADIUS);
        for (let p=minP; p<=maxP; p++){ if(rendered.has(p)){ destroyWrapper(p); rendered.delete(p); queueRender(p);} }
      });

      window.addEventListener('beforeunload', () => { try { loadingTask?.destroy(); } catch {} });
    })();
  </script>
</body>
</html>
