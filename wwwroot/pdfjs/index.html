<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PDF Viewer (virtualized + fast highlights)</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf_viewer.min.css" />
  <style>
    html, body { margin: 0; height: 100%; }
    #viewerContainer {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: auto;
      background: #f5f5f5;
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }
    #viewer {
      position: relative;
      width: auto;
      min-width: 640px;
      padding: 16px 0;
    }
    .pageOuter {
      margin: 16px auto;
      width: fit-content;
    }
    .pageLayer {
      position: relative;
      box-shadow: 0 1px 4px rgba(0,0,0,.2);
      background: white;
      line-height: 0;
    }
    /* Only the render canvas is white; highlight canvas is transparent */
    canvas { display: block; }
    .renderCanvas { background: white; z-index: 0; }
    .hlCanvas {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: transparent;
      z-index: 1;
    }
    .pageMeta {
      font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: #666; text-align: center; padding: 6px 0 0;
    }
  </style>
</head>
<body>
  <div id="viewerContainer">
    <div id="viewer"></div>
  </div>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.min.js"></script>
  <script>
    (async function () {
      const params   = new URLSearchParams(location.search);
      const file     = params.get('file')    || '';
      const overlay  = params.get('overlay') || ''; // e.g., /uploads/latest-highlights.json
      const startAt  = Math.max(1, parseInt(params.get('page') || '1', 10));

      if (!file) {
        console.error('Missing ?file=... parameter');
        return;
      }

      // PDF.js worker
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.worker.min.js';

      const viewer          = document.getElementById('viewer');
      const viewerContainer = document.getElementById('viewerContainer');

      // ---- Tuning knobs ----
      const CSS_SCALE = 1.25;                     // visual zoom (CSS pixels)
      const DPR_CAP   = 1.5;                      // cap DPR to keep canvases small
      const DPR       = Math.min(window.devicePixelRatio || 1, DPR_CAP);
      const ACTIVE_RADIUS = 3;                    // render ±N pages around viewport
      const CONCURRENCY   = 2;                    // how many pages render at once

      // ---- Load highlights once ----
      let highlightsByPage = {};
      if (overlay) {
        try {
          const res = await fetch(overlay, { cache: 'no-store' });
          highlightsByPage = await res.json();
        } catch (e) {
          console.warn('Could not load overlay JSON:', e);
        }
      }

      // ---- Open PDF with streaming + no auto-prefetch ----
      const loadingTask = pdfjsLib.getDocument({
        url: file,
        rangeChunkSize: 65536,     // 64KB ranged fetches
        disableAutoFetch: true,    // don't prefetch next pages
        disableStream: false,      // allow streaming
        withCredentials: false
      });
      const pdf = await loadingTask.promise;
      const total = pdf.numPages;

      // ---- Build lightweight DOM shells (can do all; only a few render) ----
      const pageDivs = [];
      for (let p = 1; p <= total; p++) {
        const outer = document.createElement('div');
        outer.className = 'pageOuter';

        const wrapper = document.createElement('div');
        wrapper.className = 'pageLayer';
        wrapper.dataset.pageNumber = String(p);

        const renderCanvas = document.createElement('canvas');
        renderCanvas.className = 'renderCanvas';

        const hlCanvas = document.createElement('canvas');
        hlCanvas.className = 'hlCanvas';

        wrapper.appendChild(renderCanvas);
        wrapper.appendChild(hlCanvas);

        const meta = document.createElement('div');
        meta.className = 'pageMeta';
        meta.textContent = `Page ${p} / ${total}`;

        outer.appendChild(wrapper);
        outer.appendChild(meta);
        viewer.appendChild(outer);
        pageDivs.push(wrapper);
      }

      // ---- Render queue + bookkeeping ----
      const renderTasks = new Map(); // pageNo -> { task, page }
      const rendered    = new Set(); // pages fully drawn
      const pending     = [];        // FIFO of page numbers
      let inFlight = 0;

      function queueRender(pageNumber) {
        // Don't double-queue
        if (pending.includes(pageNumber) || renderTasks.has(pageNumber) || rendered.has(pageNumber)) return;
        pending.push(pageNumber);
        pump();
      }

      async function pump() {
        if (inFlight >= CONCURRENCY || pending.length === 0) return;

        const p = pending.shift();
        inFlight++;

        const wrapper      = pageDivs[p - 1];
        const renderCanvas = wrapper.querySelector('.renderCanvas');
        const hlCanvas     = wrapper.querySelector('.hlCanvas');

        try {
          const page = await pdf.getPage(p);

          // Viewports
          const cssViewport = page.getViewport({ scale: CSS_SCALE });           // CSS px
          const devViewport = page.getViewport({ scale: CSS_SCALE * DPR });     // device px

          // Size canvases
          renderCanvas.width  = Math.floor(devViewport.width);
          renderCanvas.height = Math.floor(devViewport.height);
          renderCanvas.style.width  = Math.floor(cssViewport.width)  + 'px';
          renderCanvas.style.height = Math.floor(cssViewport.height) + 'px';

          hlCanvas.width  = renderCanvas.width;
          hlCanvas.height = renderCanvas.height;
          hlCanvas.style.width  = renderCanvas.style.width;
          hlCanvas.style.height = renderCanvas.style.height;

          // Fit wrapper to CSS size
          wrapper.style.width  = renderCanvas.style.width;
          wrapper.style.height = renderCanvas.style.height;

          const ctx = renderCanvas.getContext('2d', { alpha: false });

          // Kick off render (storable so we can cancel)
          const task = page.render({ canvasContext: ctx, viewport: devViewport });
          renderTasks.set(p, { task, page });

          await task.promise;               // throws if canceled
          renderTasks.delete(p);

          // If page is still near viewport, draw highlights; else free it
          if (Math.abs(p - nearestVisiblePage()) <= ACTIVE_RADIUS) {
            const rects = (highlightsByPage[String(p)] || highlightsByPage[p] || []);
            drawHighlights(hlCanvas, rects, cssViewport);
            rendered.add(p);
          } else {
            // went off-screen; free resources
            page.cleanup();
            // also free canvases to reclaim memory
            clearCanvases(wrapper);
          }
        } catch (err) {
          // Ignore cancellations; log others
          if (err && !String(err).includes('Rendering cancelled')) {
            console.warn('Render error on page', p, err);
          }
        } finally {
          inFlight--;
          pump();
        }
      }

      // ---- Highlight drawing (canvas, rotation-safe) ----
      function drawHighlights(hlCanvas, rects, cssViewport) {
        const ctx = hlCanvas.getContext('2d', { alpha: true });
        ctx.clearRect(0, 0, hlCanvas.width, hlCanvas.height);
        ctx.globalAlpha = 0.3;
        ctx.globalCompositeOperation = 'multiply';

        const dpr = DPR;
        // Single frame batch
        requestAnimationFrame(() => {
          for (let i = 0; i < rects.length; i++) {
            const r = rects[i];
            const w = r.w ?? r.width;
            const h = r.h ?? r.height;

            // Convert PDF-space corners to CSS-space via PDF.js (handles rotation + origin)
            const [vx1, vy1] = cssViewport.convertToViewportPoint(r.x,     r.y);
            const [vx2, vy2] = cssViewport.convertToViewportPoint(r.x + w, r.y + h);

            const leftCss   = Math.min(vx1, vx2);
            const topCss    = Math.min(vy1, vy2);
            const widthCss  = Math.abs(vx2 - vx1);
            const heightCss = Math.abs(vy2 - vy1);

            const leftDev   = Math.round(leftCss   * dpr);
            const topDev    = Math.round(topCss    * dpr);
            const widthDev  = Math.max(1, Math.round(widthCss  * dpr));
            const heightDev = Math.max(1, Math.round(heightCss * dpr));

            ctx.fillStyle = r.color || 'yellow';
            ctx.fillRect(leftDev, topDev, widthDev, heightDev);
          }
        });
      }

      // ---- Windowing: only keep ±ACTIVE_RADIUS pages alive ----
      function nearestVisiblePage() {
        const containerRect = viewerContainer.getBoundingClientRect();
        let best = 1, bestDist = Infinity;
        for (const el of pageDivs) {
          const r = el.getBoundingClientRect();
          const d = Math.abs(r.top - containerRect.top);
          if (d < bestDist) { bestDist = d; best = Number(el.dataset.pageNumber); }
        }
        return best;
      }

      function clearCanvases(wrapper) {
        const rc = wrapper.querySelector('.renderCanvas');
        const hc = wrapper.querySelector('.hlCanvas');
        if (rc) { rc.width = 1; rc.height = 1; }
        if (hc) { hc.width = 1; hc.height = 1; }
      }

      function updateActiveWindow() {
        const center = nearestVisiblePage();
        const minP = Math.max(1, center - ACTIVE_RADIUS);
        const maxP = Math.min(total, center + ACTIVE_RADIUS);

        const keep = new Set();
        for (let p = minP; p <= maxP; p++) {
          keep.add(p);
          if (!rendered.has(p) && !renderTasks.has(p)) queueRender(p);
        }

        // Cancel far-off render tasks and free memory
        for (const [p, { task, page }] of renderTasks) {
          if (!keep.has(p)) {
            try { task.cancel(); } catch {}
            renderTasks.delete(p);
            page?.cleanup();
          }
        }
        for (let p = 1; p <= total; p++) {
          if (!keep.has(p) && rendered.has(p)) {
            clearCanvases(pageDivs[p - 1]);
            rendered.delete(p);
          }
        }
      }

      // Throttle scroll handling
      let scrollRAF = 0;
      viewerContainer.addEventListener('scroll', () => {
        if (scrollRAF) cancelAnimationFrame(scrollRAF);
        scrollRAF = requestAnimationFrame(() => {
          updateActiveWindow();
          scrollRAF = 0;
        });
      });

      // Bootstrap: scroll to requested page, then compute window
      pageDivs[Math.min(total, Math.max(1, startAt)) - 1]
        .scrollIntoView({ block: 'start' });
      updateActiveWindow();

      // Re-window on resize (DPR may change on zoom; keeping it simple)
      window.addEventListener('resize', () => {
        updateActiveWindow();
      });
    })();
  </script>
</body>
</html>
