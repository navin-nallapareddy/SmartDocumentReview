@page "/"
@using Microsoft.AspNetCore.Components.Forms
@using SmartDocumentReview.Services
@using SmartDocumentReview.Models
@using SmartDocumentReview.Data
@using System.IO
@using System.Text
@using System.Text.RegularExpressions
@using System.Linq
@using System.Text.Encodings.Web
@using SmartDocumentReview.Shared
@inject AuthService AuthService
@inject PdfKeywordTagger Tagger
@inject TagDbContext Db
@inject IJSRuntime JS
@inject ResultStateService ResultStateService

<h3 class="mb-4 text-center">Smart Document Review</h3>

<div class="card shadow-sm mx-auto" style="width: 90%;">
    <div class="card-body">
        <!-- Left-aligned welcome -->
        <p class="fw-semibold mb-4 text-start">Welcome, @AuthService.CurrentUser!</p>

        <EditForm Model="this" OnValidSubmit="HandleValidSubmit">
            <div class="row justify-content-center g-3 text-center">
                <!-- Upload File -->

<div class="col-auto d-flex align-items-center gap-0">
  <label for="pdfUpload" class="form-label fw-bold mb-0">Upload PDF:</label>
  <InputFile id="pdfUpload" class="form-control" OnChange="HandleFileSelected" accept=".pdf" />
</div>


                <!-- Keywords -->
                <div class="col-auto d-flex flex-column align-items-center">
                    <label class="form-label fw-semibold">Enter keywords (one per line):</label>
                    <InputTextArea class="form-control" style="width: 250px;" @bind-Value="RawKeywordInput" Rows="3" />
                </div>

                <!-- Process Button + Spinner -->
                <div class="col-auto d-flex flex-column align-items-center">
                    <label class="form-label invisible">Action</label>
                    <div class="d-flex align-items-center gap-2">
                        <button type="submit" class="btn btn-primary" disabled="@IsProcessing">Process</button>
                        @if (IsProcessing)
                        {
                            <div class="spinner-border text-primary" style="width: 1.25rem; height: 1.25rem;" role="status">
                                <span class="visually-hidden">Processing...</span>
                            </div>
                        }
                    </div>
                    @if (IsProcessing)
                    {
                        <p class="mt-2 small">Processing... @ElapsedTime</p>
                    }
                </div>
            </div>
        </EditForm>

        @if (ErrorMessage != null)
        {
            <div class="alert alert-danger mt-3">@ErrorMessage</div>
        }
    </div>
</div>

@if (MatchedKeywords.Any())
{
    <div class="mt-4" style="display: flex; height: 90vh;">
        <!-- Left: Match Results -->
        <div style="width: 40%; overflow-y: auto; padding: 1rem;">
            @foreach (var match in MatchedKeywords)
            {
                <div style="margin-bottom: 1.5rem;">
                    <h4 @onclick="() => LoadPdfAsync(match.PageNumber)"
                        style="cursor: pointer; color: blue; text-decoration: underline;">
                        @match.SectionTitle
                    </h4>
                    <p>@(HighlightKeywords(match.MatchedText))</p>
                </div>
            }
        </div>

        <!-- Right: PDF Viewer -->
        <div style="width: 60%; height: 100%;">
            <iframe id="pdfViewer" width="100%" height="100%" frameborder="0"></iframe>
        </div>
    </div>
}

@code {
    private IBrowserFile? uploadedFile;
    public string RawKeywordInput { get; set; } = string.Empty;
    public bool IsProcessing { get; set; } = false;
    public string? ErrorMessage { get; set; }
    public string ElapsedTime { get; set; } = "00:00";

    public List<TagMatch> MatchedKeywords { get; set; } = new();
    private readonly string[] HighlightPalette = new[] { "#ffff00", "#ffb6c1", "#90ee90", "#add8e6", "#ffa07a" };
    private Dictionary<Keyword, string> keywordColors = new();
    private int? _pendingPage;

    private readonly System.Diagnostics.Stopwatch _stopwatch = new();
    private System.Timers.Timer? _timer;

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        uploadedFile = e.File;
    }

    private async Task HandleValidSubmit()
    {
        ErrorMessage = null;
        MatchedKeywords.Clear();

        if (uploadedFile == null)
        {
            ErrorMessage = "Please upload a PDF file.";
            return;
        }

        var keywords = RawKeywordInput
            .Split(new[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries)
            .Select(k => {
                var trimmed = k.Trim();
                var allowPartial = trimmed.StartsWith("*");
                var text = allowPartial ? trimmed.TrimStart('*') : trimmed;
                return new Keyword(text, allowPartial);
            })
            .Where(k => !string.IsNullOrWhiteSpace(k.Text))
            .Take(5)
            .ToList();

        keywordColors = keywords
            .Select((k, i) => new { k, i })
            .ToDictionary(x => x.k, x => HighlightPalette[x.i % HighlightPalette.Length]);

        if (!keywords.Any())
        {
            ErrorMessage = "Enter at least one keyword.";
            return;
        }

        IsProcessing = true;
        _stopwatch.Restart();
        _timer = new System.Timers.Timer(1000);
        _timer.Elapsed += (s, e) =>
        {
            ElapsedTime = _stopwatch.Elapsed.ToString(@"mm\:ss");
            InvokeAsync(StateHasChanged);
        };
        _timer.Start();

        try
        {
            using var readStream = uploadedFile.OpenReadStream(20 * 1024 * 1024);
            using var memoryStream = new MemoryStream();
            await readStream.CopyToAsync(memoryStream);
            memoryStream.Position = 0;

            MatchedKeywords = Tagger.ProcessPdf(memoryStream, keywords, AuthService.CurrentUser);
            ResultStateService.Matches = MatchedKeywords;
            ResultStateService.Keywords = keywords;

            // Save uploaded file for PDF viewer
            memoryStream.Position = 0;
            var uploadsDir = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", "uploads");
            Directory.CreateDirectory(uploadsDir);
            var savedFilePath = Path.Combine(uploadsDir, "latest.pdf");
            await using (var fs = File.Create(savedFilePath))
            {
                await memoryStream.CopyToAsync(fs);
            }

            var document = new Document
            {
                FileName = uploadedFile.Name,
                FilePath = "/uploads/latest.pdf",
                CreatedBy = AuthService.CurrentUser,
                CreatedAt = DateTime.UtcNow
            };
            Db.Documents.Add(document);
            await Db.SaveChangesAsync();

            foreach (var match in MatchedKeywords)
            {
                match.DocumentId = document.Id;
            }

            Db.TagMatches.AddRange(MatchedKeywords);
            await Db.SaveChangesAsync();

            if (MatchedKeywords.Count > 0)
            {
                _pendingPage = MatchedKeywords[0].PageNumber;
            }
        }
        catch (Exception ex)
        {
            var message = ex.InnerException?.Message ?? ex.Message;
            ErrorMessage = "Error processing PDF: " + message;
        }
        finally
        {
            IsProcessing = false;
            _timer?.Stop();
            StateHasChanged();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_pendingPage.HasValue)
        {
            await LoadPdfAsync(_pendingPage.Value);
            _pendingPage = null;
        }
    }

    async Task LoadPdfAsync(int page)
    {
        var file = "/uploads/latest.pdf";
        var highlightParams = string.Join("&", keywordColors.Select(kvp => $"highlight={Uri.EscapeDataString(kvp.Key.Text)}&color={Uri.EcapeDataString(kvp.Value)}&partial={kvp.Key.AllowPartial.ToString().ToLower()}"));
        var viewerUrl = $"/pdfjs/index.html?file={file}&page={page}&{highlightParams}";
        await JS.InvokeVoidAsync("setIframeSrc", "pdfViewer", viewerUrl);
    }

    MarkupString HighlightKeywords(string text)
    {
        if (string.IsNullOrWhiteSpace(text))
            return (MarkupString)HtmlEncoder.Default.Encode(text ?? string.Empty);

        // Collect keywords from the current color map to preserve color->keyword binding
        var allKeywords = keywordColors.Keys.ToList();
        var wholeKw = allKeywords.Where(k => !k.AllowPartial).ToList();
        var partKw  = allKeywords.Where(k =>  k.AllowPartial).ToList();

        var ranges = new List<(int start, int end, string color)>(32);

        // Helper to collect matches using named groups (?<k{i}>...) so we know which keyword matched
        static void Collect(Regex rx, string sourceText, List<Keyword> sourceKeywords, Dictionary<Keyword,string> colors, List<(int,int,string)> sink)
        {
            foreach (Match m in rx.Matches(sourceText))
            {
                for (int i = 0; i < sourceKeywords.Count; i++)
                {
                    var g = m.Groups[$"k{i}"];
                    if (g.Success)
                    {
                        var kw = sourceKeywords[i];
                        sink.Add((g.Index, g.Index + g.Length, colors[kw]));
                        break; // only one group will be set
                    }
                }
            }
        }

        if (wholeKw.Count > 0)
        {
            var rxWhole = KeywordRegex.BuildWholeWordRegex(wholeKw.Select(k => k.Text));
            Collect(rxWhole, text, wholeKw, keywordColors, ranges);
        }
        if (partKw.Count > 0)
        {
            var rxPart = KeywordRegex.BuildPartialRegex(partKw.Select(k => k.Text));
            Collect(rxPart, text, partKw, keywordColors, ranges);
        }

        if (ranges.Count == 0)
            return (MarkupString)HtmlEncoder.Default.Encode(text);

        // Sort by start, then prefer longer matches; dedupe exact spans; skip true overlaps
        var ordered = ranges
            .OrderBy(r => r.start)
            .ThenByDescending(r => r.end - r.start)
            .ToList();

        var sb = new StringBuilder(text.Length + ordered.Count * 40);
        var seen = new HashSet<(int s, int e)>();
        int cursor = 0;
        int lastEnd = -1;

        foreach (var r in ordered)
        {
            if (!seen.Add((r.start, r.end))) continue; // exact duplicate span
            if (r.start < lastEnd) continue;           // overlapping with a longer/earlier span we already kept

            if (cursor < r.start)
                sb.Append(HtmlEncoder.Default.Encode(text.AsSpan(cursor, r.start - cursor)));

            var encodedMatch = HtmlEncoder.Default.Encode(text.AsSpan(r.start, r.end - r.start));
            sb.Append($"<mark style='background-color:{r.color}'>{encodedMatch}</mark>");
            cursor = r.end;
            lastEnd = r.end;
        }

        if (cursor < text.Length)
            sb.Append(HtmlEncoder.Default.Encode(text.AsSpan(cursor)));

        return (MarkupString)sb.ToString();
    }
}
