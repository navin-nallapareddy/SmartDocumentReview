@page "/results"
@inject NavigationManager Navigation
@inject SmartDocumentReview.Services.ResultStateService ResultStateService
@inject IJSRuntime JS
@using System.Linq
@using System.Text
@using System.Text.RegularExpressions
@using System.Text.Encodings.Web
@using SmartDocumentReview.Models
@using SmartDocumentReview.Shared

<h3>Matched Results</h3>

<div style="display: flex; height: 90vh;">
    <!-- Left: Match Results -->
    <div style="width: 40%; overflow-y: auto; padding: 1rem;">
        @foreach (var match in ResultStateService.Matches)
        {
            <div style="margin-bottom: 1.5rem;">
                <h4 @onclick="() => LoadPdfAsync(match.PageNumber)"
                    style="cursor: pointer; color: blue; text-decoration: underline;">
                    @match.SectionTitle
                </h4>
                <p>@(HighlightKeywords(match.MatchedText))</p>
            </div>
        }
    </div>

    <!-- Right: PDF Viewer -->
    <div style="width: 60%; height: 100%;">
        <iframe id="pdfViewer" width="100%" height="100%" frameborder="0"></iframe>
    </div>
</div>

@code {
    private readonly string[] HighlightPalette = new[] { "#ffff00", "#ffb6c1", "#90ee90", "#add8e6", "#ffa07a" };
    private Dictionary<Keyword, string> keywordColors = new();
    private int? _pendingPage;

    protected override void OnInitialized()
    {
        var keywords = ResultStateService.Keywords;
        keywordColors = keywords.Select((k, i) => new { k, i }).ToDictionary(x => x.k, x => HighlightPalette[x.i % HighlightPalette.Length]);

        // Load first match by default after render
        if (ResultStateService.Matches.Count > 0)
        {
            var first = ResultStateService.Matches[0];
            _pendingPage = first.PageNumber;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_pendingPage.HasValue)
        {
            await LoadPdfAsync(_pendingPage.Value);
            _pendingPage = null;
        }
    }

    async Task LoadPdfAsync(int page)
    {
        var file = "/uploads/latest.pdf";
        var highlightParams = string.Join("&", keywordColors.Select(kvp => $"highlight={Uri.EscapeDataString(kvp.Key.Text)}&color={Uri.EscapeDataString(kvp.Value)}&partial={kvp.Key.AllowPartial.ToString().ToLower()}"));
        var viewerUrl = $"/pdfjs/index.html?file={file}&page={page}&{highlightParams}";
        await JS.InvokeVoidAsync("setIframeSrc", "pdfViewer", viewerUrl);
    }

    MarkupString HighlightKeywords(string text)
    {
        if (string.IsNullOrWhiteSpace(text))
            return (MarkupString)HtmlEncoder.Default.Encode(text ?? string.Empty);

        // Use the same keywords/colors currently shown in the UI
        var allKeywords = keywordColors.Keys.ToList();
        var wholeKw = allKeywords.Where(k => !k.AllowPartial).ToList();
        var partKw  = allKeywords.Where(k =>  k.AllowPartial).ToList();

        var ranges = new List<(int start, int end, string color)>(32);

        // Collect matches using named groups (?<k{i}>) to map back to the right keyword/color
        static void Collect(Regex rx, string sourceText, List<Keyword> srcKeywords, Dictionary<Keyword,string> colors, List<(int,int,string)> sink)
        {
            foreach (Match m in rx.Matches(sourceText))
            {
                for (int i = 0; i < srcKeywords.Count; i++)
                {
                    var g = m.Groups[$"k{i}"];
                    if (g.Success)
                    {
                        var kw = srcKeywords[i];
                        sink.Add((g.Index, g.Index + g.Length, colors[kw]));
                        break; // exactly one group will be set
                    }
                }
            }
        }

        if (wholeKw.Count > 0)
        {
            var rxWhole = KeywordRegex.BuildWholeWordRegex(wholeKw.Select(k => k.Text));
            Collect(rxWhole, text, wholeKw, keywordColors, ranges);
        }
        if (partKw.Count > 0)
        {
            var rxPart = KeywordRegex.BuildPartialRegex(partKw.Select(k => k.Text));
            Collect(rxPart, text, partKw, keywordColors, ranges);
        }

        if (ranges.Count == 0)
            return (MarkupString)HtmlEncoder.Default.Encode(text);

        // Deterministic ordering: start asc, then longer first
        var ordered = ranges
            .OrderBy(r => r.start)
            .ThenByDescending(r => r.end - r.start)
            .ToList();

        // Dedupe exact spans; skip true overlaps (keep earlier/longer)
        var sb = new StringBuilder(text.Length + ordered.Count * 40);
        var seen = new HashSet<(int s, int e)>();
        int cursor = 0;
        int lastEnd = -1;

        foreach (var r in ordered)
        {
            if (!seen.Add((r.start, r.end))) continue;
            if (r.start < lastEnd) continue;

            if (cursor < r.start)
                sb.Append(HtmlEncoder.Default.Encode(text.AsSpan(cursor, r.start - cursor)));

            var encodedMatch = HtmlEncoder.Default.Encode(text.AsSpan(r.start, r.end - r.start));
            sb.Append($"<mark style='background-color:{r.color}'>{encodedMatch}</mark>");

            cursor = r.end;
            lastEnd = r.end;
        }

        if (cursor < text.Length)
            sb.Append(HtmlEncoder.Default.Encode(text.AsSpan(cursor)));

        return (MarkupString)sb.ToString();
    }
}
