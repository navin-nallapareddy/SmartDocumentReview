@page "/results"
@inject NavigationManager Navigation
@inject SmartDocumentReview.Services.ResultStateService ResultStateService
@inject IJSRuntime JS
@using System.Linq
@using System.Text
@using System.Text.RegularExpressions
@using SmartDocumentReview.Models

<h3>Matched Results</h3>

<div style="display: flex; height: 90vh;">
    <!-- Left: Match Results -->
    <div style="width: 40%; overflow-y: auto; padding: 1rem;">
        @foreach (var match in ResultStateService.Matches)
        {
            <div style="margin-bottom: 1.5rem;">
                <h4 @onclick="() => LoadPdfAsync(match.PageNumber)"
                    style="cursor: pointer; color: blue; text-decoration: underline;">
                    @match.SectionTitle
                </h4>
                <p>@(HighlightKeywords(match.MatchedText))</p>
            </div>
        }
    </div>

    <!-- Right: PDF Viewer -->
    <div style="width: 60%; height: 100%;">
        <iframe id="pdfViewer" width="100%" height="100%" frameborder="0"></iframe>
    </div>
</div>

@code {
    private readonly string[] HighlightPalette = new[] { "#ffff00", "#ffb6c1", "#90ee90", "#add8e6", "#ffa07a" };
    private Dictionary<Keyword, string> keywordColors = new();
    private int? _pendingPage;

    protected override void OnInitialized()
    {
        var keywords = ResultStateService.Keywords;
        keywordColors = keywords.Select((k, i) => new { k, i }).ToDictionary(x => x.k, x => HighlightPalette[x.i % HighlightPalette.Length]);

        // Load first match by default after render
        if (ResultStateService.Matches.Count > 0)
        {
            var first = ResultStateService.Matches[0];
            _pendingPage = first.PageNumber;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_pendingPage.HasValue)
        {
            await LoadPdfAsync(_pendingPage.Value);
            _pendingPage = null;
        }
    }

    async Task LoadPdfAsync(int page)
    {
        var file = "/uploads/latest.pdf";
        var highlightParams = string.Join("&", keywordColors.Select(kvp => $"highlight={Uri.EscapeDataString(kvp.Key.Text)}&color={Uri.EscapeDataString(kvp.Value)}&partial={kvp.Key.AllowPartial.ToString().ToLower()}"));
        var viewerUrl = $"/pdfjs/index.html?file={file}&page={page}&{highlightParams}";
        await JS.InvokeVoidAsync("setIframeSrc", "pdfViewer", viewerUrl);
    }

    MarkupString HighlightKeywords(string text)
    {
        if (string.IsNullOrWhiteSpace(text)) return (MarkupString)text;

        var ranges = new List<(int start, int end, string color)>();

        foreach (var kvp in keywordColors)
        {
            var escaped = Regex.Escape(kvp.Key.Text);
            var pattern = kvp.Key.AllowPartial
                ? escaped
                : $@"(?<![\p{{L}}\p{{N}}]){escaped}(?![\p{{L}}\p{{N}}])";
            foreach (Match match in Regex.Matches(text, pattern, RegexOptions.IgnoreCase | RegexOptions.CultureInvariant))
            {
                ranges.Add((match.Index, match.Index + match.Length, kvp.Value));
            }
        }

        if (ranges.Count == 0) return (MarkupString)text;

        var ordered = ranges
            .OrderBy(r => r.start)
            .ThenByDescending(r => r.end - r.start)
            .ToList();

        var sb = new StringBuilder();
        int last = 0;
        foreach (var r in ordered)
        {
            if (r.start < last) continue; // skip overlaps
            sb.Append(text[last..r.start]);
            sb.Append($"<mark style='background-color: {r.color};'>{text[r.start..r.end]}</mark>");
            last = r.end;
        }
        sb.Append(text[last..]);

        return (MarkupString)sb.ToString();
    }
}
